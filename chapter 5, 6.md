
# 5장 정리

# 왜 형식을 맞춰야 하는가?
- 코드를 봤을 때 깔끔하고 일관적이면 전문가가 짰다는 인상을 준다. 그렇지 않다면 무성의하게 짰을 거라고 생각한다.
- 코드 형식은 의사소통의 일환.
  - 계속해서 변경되는 코드는 가독성이 유지보수 용이성과 확장성에 영향을 미친다.
  - 유지보수 과정에서 다른 사람이 코드를 고쳐야 될 경우, 형식이 맞춰져 있으면 코드를 읽기가 쉬워진다.
- 코드 형식을 맞추기 위해 규칙을을 정하고 그 규칙을 따라야 한다.


## 적당한 행 길이를 유지하라
- 소스 코드의 길이?
  - 클래스의 크기는 500줄을 넘지 않고 200줄 정도 (주식차트 그림)
  - 한 클래스가 너무 크면 하나의 기능만 하고 있는 게 아닐수도 있다
- 신문 기사처럼 작성하라
  - 소스 파일 이름은 간단하면서도 설명이 가능하게 짓는다.
  - 소스 파일 첫부분은 고차원 개념과 알고리즘, 아래로 갈수록 저차원 함수와 세부 내역 (initialize 함수같은 것도 아래에 배치하면 좋을 듯)
- 개념은 빈 행으로 분리
  - 일련의 행 묶음(중괄호 시작과 끝 같은)은 완결된 생각 하나
  - 빈 행은 새로운 개념을 시작한다는 시각적 단서 
  - 패키지 선언, import 문, 각 함수 사이에 빈 행을 넣어서 분리
- 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다. (세로밀집도)
  - 변수끼리, 메서드끼리 모아놓아라 (변수 중간에 주석을 넣어서 떨어뜨려 놓지 말아라)
  - 서로 밀접한 개념은 한 파일에 속해야 한다. (수직거리)
    - 코드 조각을 찾기 위해 이 파일 저 파일 찾아다니면 시간과 노력 소모
    - protected 변수를 피해야 한다.
  - 변수 선언
    - 지역 변수는 함수의 맨 처음에
    - 인스턴스 변수는 클래스 맨 처음에 
    - 루프 제어 변수 (i,j같은) 는 루프 문 내부에 
  - 종속 함수
    - 한 함수가 다른 함수를 호출한다면 가까이 배치하고 호출하는 함수가 호출되는 함수보다 먼저 배치
 - 개념적 유사성
   - 친화도가 높은 코드일수록 코드를 가까이 배치
   - 종속함수, 변수와 그 변수를 사용하는 함수가 예로 있다.
   - 명명법이 똑같고 기본 기능이 유사한 함수들 (assertXXX, setXXX, getXXX)
   
## 가로 형식 맞추기
- 짧은 행이 바람직. 120자 정도
- 가로는 공백을 사용해서 밀접한 개념과 느슨한 개념을 표현
  - 할당 연산자 (=) 앞뒤에 공백
  - 함수 이름과 괄호는 공백 없이
  - 함수 호출시 인자들은 쉼표 다음에 공백주기
  - 연산자 우선순위를 표현하기 위해 나중에 계산되는 연산자 앞뒤로 공백
- 들여쓰기 
  - 소스 파일은 outline과 계층이 비슷
    - 파일 전체 정보 -> 개별 클래스 정보 -> 각 메시드 정보 ..
  - 범위로 이루어진 계층을 표현하기 위해 들여씀
  - 짧은 if, while, 함수 같은 경우에도 한 줄에 쓰기 말고 들여쓰기를 해서 범위를 제대로 표현하는 걸 선호
- 비어있는 while문이나 for문의 경우 다음 행에 세미콜론을 넣어서 표현

## 팀 규칙
- 팀은 한 가지 규칙에 합의해야 한다.
  - 괄호는 어디에 쓸건지, 들여쓰기는 몇자리 할 건지, 클래스와 변수 메서드 이름은 어떻게 지을지 등등..
- https://github.com/PRNDcompany/android-style-guide/blob/main/Kotlin.md 
다음은 헤이딜러 안드로이드 팀의 코딩 컨벤션이다. 명명법부터 개행을 언제는 하고 안 할 건지 등등을 미리 문서로 정해놓으면 여러 사람이 짰어도 형식이 맞기 때문에 일관성 있고 가독성 있는 코드가 된다. 
  
## 코드 개선
- 사실 이미 다 지키고 있었을 것이다.
- IDE에 기본적으로 설정되어 있는 formatting이 위 내용을 대부분 따르고 있을 것이기 때문


---
# 6장 정리



## 자료 추상화
- 구현을 감추려면 추상화가 필요하다
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.
- 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.

``` kotlin
class Point{
	var x:Double
    var y:Double
}
```
- 구현이 외부로 노출
  - 개별적으로 좌표값을 읽고 설정할 수 있음

``` kotlin
interface Point{
	fun getX(): Double
	fun getY(): Double
    fun setCartesian(x: Double, y: Double)
    fun getR(): Double
    fun getTheta(): Double
    fun setPolar(r: Double, theta: Double)
}
```
- 좌표를 설정할 때는 두 값을 한번에 설정하고 좌표를 읽을 때는 개별적으로 읽도로 접근 정책을 제한


```kotlin
interface Vehicle {
	fun getFuelTankCapacityInGallons(): Double
    fun getGallonsOfGasoline(): Double
}
```
- 단순히 연료상태에 대한 상태를 각 변수를 읽어와서 알려줌

``` kotlin
interface Vehicle {
	fun getPercentFuelRemaining(): Double
}
```
- 연료 상태를 백분율이라는 추상적인 개념으로 알려줌
  - 백분율이 어떤 정보를 통해서 오는지 드러나지 않는다.


## 자료/객체 비대칭
- 객체는 추상화 뒤로 자료를 숨긴채 자료를 다루는 함수만 제공
- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않음

- 자료구조를 사용하는 절차적인 코드 
  - 기존 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉬움
  - 책에 Gemoetry 코드처럼 새로운 함수는 if문으로 무슨 구조일 때 ~ 나눠서 구현하면 됨
- 객체 지향 코드는
  - 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
  - 위 경우에서 if문들을 각 자료구조 내에 구현하였기 때문에 기존 함수를 수정하면 모든 자료구조들이 구현한 함수를 수정해야 함
  
 
## 디미터 법칙
- 휴리스틱 (경험적인, 직관적 판단에 의하여 문제를 해결하는 방식) 
- 모듈은 자신이 조사하는 객체의 속사정을 몰라야 한다.
- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
  - 클래스 C
  - f가 생성한 객체
  - f 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체
  
``` kotlin
val outputDir:String = ctxt.getOptions().getScratchDir().getAbsolutePath()
```
- 메서드가 반환하는 객체의 메서드는 호출하면 안된다.
- 위와 같은 코드를 기차충돌이라고 부르는다. 일반적으로 조잡하다고 여겨지므로 피하는 편이 좋다.
- 반환하는 값들이 전부 자료구조라면 내부구조가 노출되므로 디미터 법칙에 적용되지 않는다.
- 근데 객체라면 디미터 법칙을 어긴 것

## 구조체 감추기
- 잡종 구조
  - 자료구조와 객체가 섞여있는 형태
  - 중요한 기능을 하는 함수와 (객체지향) 공개 조회/설정 함수로 비공개 변수를 노출하는 함수 (자료구조)가 섞여있어 새로운 함수는 물론 새로운 자료 구조도 추가하기 어려움
``` kotlin
val outputDir: String = ctxt.getOptions().getScratchDir().getAbsolutePath()
```
여기서 ctxt가 진짜 객체라면 내부 구조를 감춰야하기 때문에 줄줄이 늘어놓으면 안 된다.
- ctxt에게 뭔가를 하라고 해야지 원하는 자료 구조를 반환하게 하면 안된다.
``` kotlin
val bos: BufferedOutputStream = ctxt.createScratchFileStream(classFileName)
```
ctxt는 내부 구조를 드러내지 않으면 모듈에서는 자신이 몰라야 하는 객체들을 탐색할 필요가 없어진다.


## 자료 전달 객체
- 공개 변수만 있고 함수가 없는 클래스 
- Data Transfer Object (DTO)라 부른다.
- 데이터베이스와 통신하거나 가공되지 않은 데이터베이스 정보를 애플리케이션코드에서 사용할 객체로 변환하는 단계에서 사용
```kotlin
data class User(
    val nickname: String,
    val uid: String,
    val lastLogin: Long,
    val isGuest: Boolean,
)

data class UserDTO(
    @SerializedName("nickname") val nickname: String,
    @SerializedName("uid") val uid: String,
    @SerializedName("lastLogin") val lastLogin: Long,
    @SerializedName("isGuest") val isGuest: Boolean,
)

fun User.toUserDto(): UserDTO {
    return UserDTO(
        nickname = nickname,
        uid = uid,
        lastLogin = lastLogin,
        isGuest = isGuest
    )
}

```

- 비공개 변수를 조회/설정 함수로 조작하는 좀 더 일반적인 형태의 빈(bean)구조도 있다.


### 활성 레코드
- DTO의 특수한 형태
- 자료구조에서 조회/설정 뿐만 아니라 save, find같은 탐색 함수도 제공
- 활성레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과
- 활성 레코드는 자료구조로 취급한다.
  - 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성해야 한다.
  

## 결론
 - 객체
   - 동작을 공개하고 자료를 숨김
   - 새 객체 타입 쉬움
   - 새로운 동작 추가 어려움
 - 자료구조
   - 별다른 동작없이 자료를 노출
   - 새 동작 추가 쉬움
   - 새 자료구조 추가 어려움
 - 시스템 구현 시, 새로운 자료 타입 추가 or 새로운 동작 추가 유연성의 필요에 따라 객체 or 자료구조 선택
